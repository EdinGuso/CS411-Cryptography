# -*- coding: utf-8 -*-
"""edin_client_phase3.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/176jRv158aFqq2rKMVnKxXqpnVMHnRG6f
"""

print('Run this code block to import the libraries')
!pip install ecpy
!pip install pycryptodome
import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256, SHA256, HMAC
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import hashlib, hmac, binascii
import json

API_URL = 'http://cryptlygos.pythonanywhere.com'

print('Run this code block to declare the functions')
def generateKey(P,n):
  s_l = randint(1,n-2)
  Q_l = P.mul(s_l)
  return Q_l,s_l
  
def generateSignature(P,s_l,n,m):
  k = randint(1,n-2)
  R = P.mul(k)
  r = R.x % n
  r = r.to_bytes((r.bit_length()+7)//8,byteorder='big')
  temp = SHA3_256.new(m+r)
  h = int.from_bytes(temp.digest(), byteorder='big') %n
  s = ((s_l * h) + k) % n
  return h,s

print('Run this code block to create the necessary variables')
stuID = '23435'
#stuID_B = '18007'
stuID_B = '23521'

#create a long term key
curve = Curve.get_curve('secp256k1')
n = curve.order
P = curve.generator

#Q_l,s_l = generateKey(P,n)
s_l = 66330753584552058499743612426655728498583790695777331302828810621340425279803
Q_l = Point(0xff15bf0935a8167c48e31ee0b81643eddc26cab170a5d25155b72fdcdd4e57c4,0x17c9839a3564de11a83fed280035b7891de6e7c2f95a9ef3345d7a09368d72f0, curve) 
#print('s_l (private key) =',s_l)
#print('Q_l (public key) =',Q_l)
#print('\n')

print('Run this code block to check status')
h,s = generateSignature(P,s_l,n,stuID.encode())
mes = {'ID_A':stuID, 'H': h, 'S': s}
response = requests.get('{}/{}'.format(API_URL, "Status"), json = mes)
print("Status ", response.json())

print('Run this code block to register long term key')
h, s = generateSignature(P,s_l,n,stuID.encode())
mes = {'ID':stuID, 'H': h, 'S': s, 'LKEY.X': Q_l.x, 'LKEY.Y': Q_l.y}
response = requests.put('{}/{}'.format(API_URL, "RegLongRqst"), json = mes)
print(response.json())

code = int(input())

mes = {'ID':stuID, 'CODE': code}
response = requests.put('{}/{}'.format(API_URL, "RegLong"), json = mes)
print(response.json())

print('Run this code block to register ephemeral keys')
#Create ephemeral keys
ephemeral_keys = {}
for i in range(10):
  Q_A,s_A = generateKey(P,n)
  ephemeral_key = {'Q_A':Q_A, 's_A':s_A}
  ephemeral_keys[i] = ephemeral_key

#Register ephemeral keys
for i in range(len(ephemeral_keys)):
  #Sign ephemeral key
  ephemeral_key = ephemeral_keys[i] 
  ekey = ephemeral_key['Q_A']
  m = str(ekey.x) + str(ekey.y)
  m = m.encode()
  h,s = generateSignature(P,s_l,n,m)

  #Send ephemeral key
  mes = {'ID': stuID, 'KEYID': i , 'QAI.X': ekey.x, 'QAI.Y': ekey.y, 'Si': s, 'Hi': h}
  response = requests.put('{}/{}'.format(API_URL, "SendKey"), json = mes)
  print(response.json())

print('Run this code block to sign, encrypt and send messages')
#Sign ID_B
h_B, s_B = generateSignature(P,s_l,n,stuID_B.encode())

#Get key of the Student B
mes = {'ID_A': stuID, 'ID_B':stuID_B, 'S': s_B, 'H': h_B}
response = requests.get('{}/{}'.format(API_URL, "ReqKey"), json = mes)
res = response.json()
print(res)

i = res['i']
j = res['j']
QBJ = Point(res['QBJ.x'],res['QBJ.y'],curve)
s_a_i = ephemeral_keys[int(i)]['s_A']

T = s_a_i*QBJ
U = str(T.x) + str(T.y) + "NoNeedToRunAndHide"
U_byte = U.encode()
k_enc_ab = SHA3_256.new(U_byte).digest()
k_mac_ab = SHA3_256.new(k_enc_ab).digest()

ptext = "The world is full of lonely people afraid to make the first move."
cipher = AES.new(k_enc_ab, AES.MODE_CTR)
nonce = cipher.nonce 
ctext = cipher.encrypt(ptext.encode())

temp = HMAC.new(k_mac_ab, digestmod=SHA256)
temp.update(ctext)
mac = temp.digest()

msg = nonce + ctext + mac
msg = int.from_bytes(msg,byteorder='big')

#Send message to student B
mes = {'ID_A': stuID, 'ID_B':stuID_B, 'I': i, 'J':j, 'MSG': msg}
response = requests.put('{}/{}'.format(API_URL, "SendMsg"), json = mes)
print(response.json())

print('Run this code block to receive, verify and decrypt messages')
#Get your message
mes = {'ID_A': stuID, 'S': s, 'H': h}
response = requests.get('{}/{}'.format(API_URL, "ReqMsg_PH3"), json = mes)
print(response.json())

if response.ok:
  #Verify message
  i = response.json()['KEYID']
  QBJ = Point(response.json()['QBJ.X'],response.json()['QBJ.Y'],curve)

  s_a_i = ephemeral_keys[int(i)]['s_A']
  T = s_a_i*QBJ
  U = str(T.x) + str(T.y) + "NoNeedToRunAndHide"
  U_byte = U.encode()
  k_enc_ab = SHA3_256.new(U_byte).digest()
  k_mac_ab = SHA3_256.new(k_enc_ab).digest()

  incoming_msg = response.json()['MSG']
  msg = incoming_msg.to_bytes((incoming_msg.bit_length()+7)//8,byteorder='big')
  nonce = msg[:8]
  ctext = msg[8:len(msg)-32]
  mac = msg[len(msg)-32:]

  temp = HMAC.new(k_mac_ab, digestmod=SHA256)
  temp.update(ctext)
  temp_dig = temp.digest()

  if temp_dig == mac:
    print("Message is authentic")
  else:
    print("Message is not authentic")

  #Decrypt message
  cipher = AES.new(k_enc_ab, AES.MODE_CTR,nonce=nonce)
  all = cipher.decrypt(ctext)
  ptext = all.decode()
  print(ptext + '\n')

print('Run this code block to reset ephemeral keys')
m = stuID.encode()
h,s = generateSignature(P,s_l,n,m)

mes = {'ID': stuID, 'S': s, 'H': h}
response = requests.get('{}/{}'.format(API_URL, "RstEKey"), json = mes)

print('Run this code block to reset long term key')
mes = {'ID': stuID}
response = requests.get('{}/{}'.format(API_URL, "RstLongRqst"), json = mes)
print(response.json())
code = int(input())

mes = {'ID': stuID ,'CODE': code}
response = requests.get('{}/{}'.format(API_URL, "RstLong"), json = mes)
print(response.json())