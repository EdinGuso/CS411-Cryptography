# -*- coding: utf-8 -*-
"""client.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-o8rXn71osL7nxmVuaWBuZuIlYObpnFm
"""

#!pip install ecpy
#!pip install pycryptodome

import math
import timeit
import random
import sympy
import warnings
from random import randint, seed
import sys
from ecpy.curves import Curve,Point
from Crypto.Hash import SHA3_256
import requests
from Crypto.Cipher import AES
from Crypto import Random
from Crypto.Util.Padding import pad
from Crypto.Util.Padding import unpad
import random
import re
import json
from Crypto.Util import Counter
API_URL = 'http://cryptlygos.pythonanywhere.com'

stuID = '23435'

def generateKey(P,n):
  s_l = randint(1,n-2)
  Q_l = P.mul(s_l)
  return Q_l,s_l

def generateSignature(P,s_l,n,m):
  k = randint(1,n-2)
  R = P.mul(k)
  r = R.x % n
  r = r.to_bytes((r.bit_length()+7)//8,byteorder='big')
  temp = SHA3_256.new(m+r)
  h = int.from_bytes(temp.digest(), byteorder='big') %n
  s = ((s_l * h) + k) % n
  return h,s

def verifySignature(P,s,h,Q_A,n,m):
  V = s*P - h*Q_A
  v = V.x %n
  v = v.to_bytes((v.bit_length()+7)//8,byteorder='big')
  temp = SHA3_256.new(m+v) 
  h_prime = int.from_bytes(temp.digest(), byteorder='big') %n

  print("h_prime",h_prime)
  print("h",h)
  if h_prime == h:
    print("Signature is verified!")
    return True
  else:
    print("Signature is not verified!")
    return False


#HERE CREATE A LONG TERM KEY
print('HERE CREATE A LONG TERM KEY')
curve = Curve.get_curve('secp256k1')
n = curve.order
P = curve.generator

#Q_l,s_l = generateKey(P,n)
s_l = 66330753584552058499743612426655728498583790695777331302828810621340425279803
Q_l = Point(0xff15bf0935a8167c48e31ee0b81643eddc26cab170a5d25155b72fdcdd4e57c4,0x17c9839a3564de11a83fed280035b7891de6e7c2f95a9ef3345d7a09368d72f0, curve) 

print('s_l (private key) =',s_l)
print('Q_l (public key) =',Q_l)
print('\n')
lkey = Q_l

#server's long term key
QSer_long = Point(0xc1bc6c9063b6985fe4b93be9b8f9d9149c353ae83c34a434ac91c85f61ddd1e9 , 0x931bd623cf52ee6009ed3f50f6b4f92c564431306d284be7e97af8e443e69a8c, curve)

# GENERATE SIGNATURE
print('GENERATE SIGNATURE')
m = stuID.encode()
print('m:',m)
h,s = generateSignature(P,s_l,n,m)
print('h:',h)
print('s:',s)
print('\n')

# HERE GENERATE A EPHEMERAL KEY 
print('HERE GENERATE A EPHEMERAL KEY')
Q_A,s_A = generateKey(P,n)
print('s_A (private key) =',s_A)
print('Q_A (public key) =',Q_A)
print('\n')
ekey = Q_A

try:
  '''
  #REGISTRATION
  mes = {'ID':stuID, 'h': h, 's': s, 'LKEY.X': lkey.x, 'LKEY.Y': lkey.y}
  response = requests.put('{}/{}'.format(API_URL, "RegStep1"), json = mes)		
  if((response.ok) == False): raise Exception(response.json())
  print(response.json())

  print("Enter verification code which is sent to you: ")	
  code = int(input())

  mes = {'ID':stuID, 'CODE': code}
  response = requests.put('{}/{}'.format(API_URL, "RegStep3"), json = mes)
  if((response.ok) == False): raise Exception(response.json())
  print(response.json())
  '''

	#STS PROTOCOL
  print('STS PROTOCOL')

  mes = {'ID': stuID, 'EKEY.X': ekey.x, 'EKEY.Y': ekey.y}
  response = requests.put('{}/{}'.format(API_URL, "STSStep1&2"), json = mes)
  if((response.ok) == False): raise Exception(responce.json())
  res=response.json()

  #convert dict to point
  Q_B = Point(res['SKEY.X'],res['SKEY.Y'],curve)
  print('Q_B:',Q_B)

	#calculate T,K,U
  T = Q_B.mul(s_A)
  temp = "BeYourselfNoMatterWhatTheySay"
  U = str(T.x)+str(T.y)+temp
  U = U.encode()
  K = SHA3_256.new(U).digest()
  print('K:',K)
  print('')

	#Sign Message
  print('Sign Message')
  W_1 = str(Q_A.x) + str(Q_A.y) + str(Q_B.x) + str(Q_B.y)
  W_1 = W_1.encode()
  print('W_1:',W_1)
  sigA_h,sigA_s = generateSignature(P,s_l,n,W_1)
  print('sigA_h:',sigA_h)
  print('sigA_s:',sigA_s)
  print('')

	#Encryption
  print('Encryption')
  text = "s" + str(sigA_s) + "h" + str(sigA_h)
  cipher = AES.new(K, AES.MODE_CTR)
  ptext = text.encode()
  print('ptext:',ptext)
  ctext = cipher.nonce + cipher.encrypt(ptext)
  ctext = int.from_bytes(ctext,byteorder='big')
  print('ctext:',ctext)
  print('')
  
	###Send encrypted-signed keys and retrive server's signed keys
  mes = {'ID': stuID, 'FINAL MESSAGE': ctext}
  response = requests.put('{}/{}'.format(API_URL, "STSStep4&5"), json = mes)
  if((response.ok) == False): raise Exception(response.json()) 
  ctext= response.json() 

	#Decrypt 
  print('Decryption')
  print('ctext:',ctext)
  ctext = ctext.to_bytes((ctext.bit_length()+7)//8,byteorder='big')
  cipher = AES.new(K, AES.MODE_CTR,nonce = ctext[0:8])
  ptext = cipher.decrypt(ctext[8:])
  print('ptext:',ptext)
  print('')
  text = ptext.decode()

  s_text = int(text[1:text.find('h')])
  h_text = int(text[text.find('h')+1:])

	#verify
  print('Verification')
  W_2 = str(Q_B.x) + str(Q_B.y) + str(Q_A.x) + str(Q_A.y)
  W_2 = W_2.encode()
  verifySignature(P,s_text,h_text,QSer_long,n,W_2)

	#get a message from server for 
  mes = {'ID': stuID}
  response = requests.get('{}/{}'.format(API_URL, "STSStep6"), json=mes)
  ctext= response.json()
	
	#Decrypt
  ctext = ctext.to_bytes((ctext.bit_length()+7)//8,byteorder='big')
  cipher = AES.new(K, AES.MODE_CTR,nonce=ctext[0:8])
  all = cipher.decrypt(ctext[8:])
  all = all.decode()
  message = all[0:all.find(".")+1]
  rand = all[all.find(".")+2:]
  rand = int(rand)
  print("")
  print("SECTION2.2 STEP 6")
  print("Message from server:",all)
  print("RAND =",rand)
  print("MESSAGE =",message)
  print("")

	#Add 1 to random to create the new message and encrypt it
  rand = rand+1
  new_message = message +" "+ str(rand)
  print("MessageToServer =",new_message)
  print("")
  cipher = AES.new(K, AES.MODE_CTR)
  new_message = new_message.encode()
  ctext = cipher.nonce + cipher.encrypt(new_message)
  ct = int.from_bytes(ctext,byteorder='big')

	#send the message and get response of the server
  mes = {'ID': stuID, 'ctext': ct}
  response = requests.put('{}/{}'.format(API_URL, "STSStep7&8"), json = mes)
  ctext= response.json()         

  ctext = ctext.to_bytes((ctext.bit_length()+7)//8,byteorder='big')
  cipher = AES.new(K, AES.MODE_CTR,nonce=ctext[0:8])
  all = cipher.decrypt(ctext[8:])
  all = all.decode()
  message = all[0:all.find(".")+1]
  rand = all[all.find(".")+2:]
  rand = int(rand)
  print("SECTION2.2 STEP 7")
  print("Expected message from server,",all)

except Exception as e:
  print(e)

"""s_l (private key) = 66330753584552058499743612426655728498583790695777331302828810621340425279803
Q_l (public key) = (0xff15bf0935a8167c48e31ee0b81643eddc26cab170a5d25155b72fdcdd4e57c4 , 0x17c9839a3564de11a83fed280035b7891de6e7c2f95a9ef3345d7a09368d72f0)

"""